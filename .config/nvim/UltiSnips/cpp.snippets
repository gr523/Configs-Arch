snippet dr4
int di[]={0,0,1,-1},
	dj[]={1,-1,0,0};
endsnippet



snippet kfor
for(int ${1:k};${1:k}<n;${1:k}++){
	${2:}
}
endsnippet



snippet bigmod
ll BigMod(ll base,ll power,ll mod){
	ll result=1;
	while(power){
		if(power&1)
			result=(result*base)%mod;
		base=(base*base)%mod;
		power>>=1LL;
	}
	return result;
}
endsnippet



snippet case
cout<<"Case "<<T++<<": ";
endsnippet



snippet c++_io
#include <bits/stdc++.h>
#define ll long long
#define localhost 
using namespace std;
int main(){
#ifdef localhost
	freopen("Input.txt","r",stdin); freopen("Output.txt","w",stdout);
#endif

	${1:}
}
endsnippet



snippet clockend
end=clock();
double time=double(end-start)/double(CLOCKS_PER_SEC);
cout<<setprecision(5)<<fixed<<time<<"\n";
endsnippet



snippet clockstart
clock_t start,end;
start=clock();
endsnippet



snippet divisorcount
ll countdivisors(ll n){
	ll c,total=1,N=n;	
	for(int i=0;primes[i]*primes[i]<=n;++i){
		if(n%primes[i]==0){
			c=1;
			while(n%primes[i]==0){
				n/=primes[i];
				.c++,source.c;
			}
			total*=c;
		}
	}
	if(n>1) total<<=1;
	return total;
}
endsnippet



snippet out
cout<<${1:s}<<"\n";
endsnippet



snippet cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
int main(){
	${1:}
}
endsnippet



snippet dcon
#define done(x) {cout<<x<<"\n";continue;} 
endsnippet



snippet ddarr
#define darr(arr,i) cout<<#arr<<"["<<i<<"] = "<<arr[i]<<"\n";
endsnippet



snippet dld
#define ld long double
endsnippet



snippet dret
#define done(x) {cout<<x<<"\n";return 0;} 
endsnippet



snippet eb
emplace_back(${1:tmp});
endsnippet



snippet fast
ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);
endsnippet



snippet first
first
endsnippet



snippet forone "For Loop"
for(int ${2:i}=1;$2<=${1:n};${3:++$2}){

}
endsnippet



snippet forsimple
for(auto i:${1:arr}){

}
endsnippet



snippet yesno
cout<<(${1:f}?"YES\n":"NO\n");	
endsnippet



snippet jofor
for(int i=1;i<=${1:n};i++) 
endsnippet



snippet jfor
for(int i=0;i<${1:n};i++) 
endsnippet



snippet for
for(int i=0;i<${1:n};i++){

} 
endsnippet



	snippet jsfor
for(auto i:${1:arr}) 
	endsnippet



	snippet mod_kmp
	void kmp(string &text,string &pattern,int *lps){

		int n=pattern.length(),l=text.length(),i=0,j=0;
		lps[0]=0;
		//i-----j//
		for(j=1;j<n;){
			if(pattern[i]==pattern[j]) lps[j]=i+1,i++,j++;
			else {
				if(i) i=lps[i-1];
				else lps[j]=0,j++;
			}
		}
		//j---------i//
		i=0,j=0;
		while(i<l){
			if(pattern[j]==text[i])
				i++,j++;
			else {
				if(j) j=lps[j-1];
				else i++;
			}
			if(j==n){
				j=lps[j-1];
			}
		}
	}
endsnippet



snippet mod_lqa
ll lqa(ll *arr,int n,ll value){
	ll i=lower_bound(arr,arr+n,value)-arr;
	if(i==0 && arr[i]>value) return -1;
	if(i==n) i--;
	if(arr[i]>value && i) i--;	
	return i;
}
endsnippet



snippet memset
memset(${1:arr},0,sizeof(${1:arr}));
endsnippet



snippet mod_mulmod
ll mulmod(ll a,ll b,ll mod){
	ll result = 0; a%=mod;
	while(b){
		if(b&1) 
			result = (result+a)%mod ;
		a=(a<<1LL)%mod;
		b>>=1LL;
	}
	return result%mod ;
}
endsnippet



snippet mod_ncr
ll mem[102][102];
ll nCr(ll n,ll r){
	if(mem[n][r]!=0)
		return mem[n][r];
	if(n==r || r==0) 
		return mem[n][r]=1;
	if(n-r==1 || r==1)
		return mem[n][r]=n;
	return mem[n][r]=nCr(n-1,r-1)+nCr(n-1,r); 
}
endsnippet



snippet nest
for(int i=0;i<n;i++){
	for(int j=0;j<${2:n};j++){

	}
}
endsnippet



snippet pair
pair<int,int>${1:edges}
endsnippet



snippet pascal
ll ncr[150][150];
void pascal(int n){
	for(int i=1;i<=n;i++){
		ncr[i][0]=1,ncr[i][1]=i;
		for(int j=2;j<=n;j++)
			ncr[i][j]=ncr[i-1][j]+ncr[i-1][j-1];
	}	
}
endsnippet



snippet phi_calc
ll calcphi(ll n){
	ll val=sqrt(n)+1,s=n;
	for(ll i=2;i<val;++i){
		if(n%i==0){
			s*=(i-1),s/=i;
			while(n%i==0) n/=i;
		}
	}
	if(n>1) s*=(n-1),s/=n;
	return s;
}
endsnippet



snippet phi_init
const int mx=(int)1e3;
int phi[mx+1];
void initphi(){
	phi[1]=1;
	for(ll i=2;i<=mx;++i){
		if(!phi[i]){
			phi[i]=i-1;
			for(ll j=2*i;j<=mx;j+=i){
				if(!phi[j]) phi[j]=j;
				phi[j]=phi[j]/i*(i-1);
			}
		}
	}
}
endsnippet



snippet preciseprint
cout<<setprecision(10)<<fixed<<${1:ans}<<"\n";
endsnippet



snippet pb
push_back(${1:tmp});
endsnippet



snippet reversesort
sort(${1:arr},${1:arr}+n,greater<ll>());
endsnippet



snippet rfor
for(int i=${1:n}-1;i>=0;i--){

}
endsnippet



snippet rjfor
for(int i=${1:n}-1;i>=0;i--) 
endsnippet



snippet second
second
endsnippet



snippet sort
sort(${1:arr},${1:arr}+n);
endsnippet



snippet sorzero
(${1:f})?cout<<s<<"\n":cout<<0<<"\n";
endsnippet



snippet len
${1:}.length();
endsnippet



snippet take
for(int i=0;i<n;i++) cin>>${1:arr}[i];
endsnippet



snippet T--
int t,T=1;cin>>t;
while(t--){
	${1:}
}
endsnippet



snippet t--
int t;cin>>t;
while(t--){
	${1:}
}
endsnippet



snippet vi
vector<int>${1:arr}
endsnippet



snippet vreversesort
sort(${1:arr}.rbegin(),${1:arr}.rend());
endsnippet



snippet vsort
sort(${1:arr}.begin(),${1:arr}.end());
endsnippet



snippet mod_bigint
struct Bigint {
	string a;
	int sign;
	Bigint(){}
	void operator = (string b) {
		a= (b[0]=='-' ? b.substr(1) : b);
		reverse(a.begin(), a.end());
		(*this).Remove0(b[0]=='-' ? -1 : 1);
	}
	Bigint(string x) {(*this)=x;}
	Bigint(ll x) {(*this)=to_string(x);}
	void operator = (ll x){*this=to_string(x);}
	char operator[](int i){return a[i];}
	int size() {return a.size();}
	Bigint inverseSign() {sign*=-1; return (*this);}
	Bigint Remove0(int newSign) {
		sign = newSign;
		for(int i=a.size()-1; i>0 && a[i]=='0'; i--) a.pop_back();
		if(a.size()==1 && a[0]=='0') sign=1;
		return (*this);
	}
	bool operator == (Bigint x) {return sign==x.sign && a==x.a;}
	bool operator == (string x) {return *this==Bigint(x);}
	bool operator == (ll x)     {return *this==Bigint(x);}
	bool operator != (Bigint x) {return !(*this==x);}
	bool operator != (string x) {return !(*this==x);}
	bool operator != (ll x)     {return !(*this==x);}
	bool operator < (Bigint b) {
		if (sign!=b.sign) return sign<b.sign;
		if(a.size()!=b.size()) return a.size()*sign<b.size()*sign;
		for(int i=a.size()-1; i>=0; i--)
			if(a[i] != b[i]) return a[i]<b[i];
		return false;
	}
	bool operator <  (string x) {return *this<Bigint(x);}
	bool operator <  (ll x)     {return *this<Bigint(x);}
	bool operator <= (Bigint b) {return *this==b || *this<b;}
	bool operator <= (string b) {return *this==b || *this<b;}
	bool operator <= (ll b)     {return *this==b || *this<b;}
	bool operator >  (Bigint b) {return !(*this==b || *this<b);}
	bool operator >  (string x) {return !(*this==x || *this<x);}
	bool operator >  (ll b)     {return !(*this==b || *this<b);}
	bool operator >= (Bigint b) {return *this==b || *this>b;}
	bool operator >= (string b) {return *this==b || *this>b;}
	bool operator >= (ll b)     {return *this==b || *this>b;}
	Bigint operator + (Bigint b) {
		if(sign != b.sign) return (*this)-b.inverseSign();
		Bigint sum;
		for(int i=0, carry=0; i<a.size() || i<b.size() || carry; i++){
			if (i<a.size()) carry+=a[i]-'0';
			if (i<b.size()) carry+=b[i]-'0';
			sum.a += (carry % 10 + 48);
			carry /= 10;
		}
		return sum.Remove0(sign);
	}
	Bigint operator +  (string x) {return *this+Bigint(x);}
	Bigint operator +  (ll x)     {return *this+Bigint(x);}
	Bigint operator ++ (int) {*this+=1; return *this-1;}
	Bigint operator ++ ()    {*this+=1; return *this;}
	void operator += (Bigint x) {*this = *this+x;}
	void operator += (string x) {*this = *this+x;}
	void operator += (ll x)     {*this = *this+x;}
	Bigint operator - ( Bigint b ) {
		if(sign != b.sign) return (*this)+b.inverseSign();
		if(*this < b) return (b - *this).inverseSign();
		Bigint sub;
		for(int i=0,borrow=0; i<a.size(); i++) {
			borrow = a[i]-borrow-(i<b.size() ? b.a[i] : '0');
			sub.a += borrow>=0 ? borrow+'0' : borrow + 58;
			borrow = borrow>=0 ? 0:1;
		}
		return sub.Remove0(sign);
	}
	Bigint operator - (string x) {return *this-Bigint(x);}
	Bigint operator - (ll x)     {return *this-Bigint(x);}
	Bigint operator -- (int) {*this-=1; return *this+1;}
	Bigint operator -- ()    {*this-=1; return *this;}
	void operator -= (Bigint x) {*this = *this-x;}
	void operator -= (string x) {*this = *this-x;}
	void operator -= (ll x)     {*this = *this-x;}
	Bigint operator * (Bigint b) {
		Bigint mult("0");
		for(int i=0, k=a[i]; i<a.size(); i++, k=a[i]) {
			while(k-- -'0') mult=mult+b;
			b.a.insert(b.a.begin(),'0');
		}
		return mult.Remove0(sign * b.sign);
	}
	Bigint operator * (string x) {return *this*Bigint(x);}
	Bigint operator * (ll x)     {return *this*Bigint(x);}
	void operator *= (Bigint x) {*this = *this*x;}
	void operator *= (string x) {*this = *this*x;}
	void operator *= (ll x)     {*this = *this*x;}
	Bigint operator / (Bigint b) {
		if(b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0');
		Bigint c("0"), d;
		for(int j=0; j<a.size(); j++) d.a += "0";
		int dSign = sign*b.sign; b.sign=1;
		for(int i=a.size()-1; i>=0; i--) {
			c.a.insert(c.a.begin(),'0');
			c=c+a.substr(i,1);
			while(!(c<b)) c=c-b, d.a[i]++;
		}
		return d.Remove0(dSign);
	}
	Bigint operator / (string x) {return *this/Bigint(x);}
	Bigint operator / (ll x)     {return *this/Bigint(x);}
	void operator /= (Bigint x) {*this = *this/x;}
	void operator /= (string x) {*this = *this/x;}
	void operator /= (ll x)     {*this = *this/x;}
	Bigint operator % (Bigint b) {
		if( b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0') ;
		Bigint c("0");
		int cSign = sign*b.sign; b.sign=1;
		for( int i=a.size()-1; i>=0; i-- ) {
			c.a.insert( c.a.begin(),'0');
			c = c+a.substr(i,1);
			while(!(c<b)) c=c-b;
		}
		return c.Remove0(cSign);
	}
	Bigint operator % (string x) {return *this%Bigint(x);}
	Bigint operator % (ll x)     {return *this%Bigint(x);}
	void operator %= (Bigint x) {*this = *this%x;}
	void operator %= (string x) {*this = *this%x;}
	void operator %= (ll x)     {*this = *this%x;}
	void print() {
		if(sign==-1) putchar('-');
		for(int i=a.size()-1; i>=0; i--) putchar(a[i]);
	}
	friend istream& operator >>(istream &in,Bigint &x){
		string s; in>>s; x=s; return in;
	}
	friend ostream& operator <<(ostream &out,Bigint &x){
		if(x.sign==-1) putchar('-');
		for(int i=x.size()-1; i>=0; i--)
			putchar(x[i]);
		return out;
	}
	friend Bigint pow(Bigint base,Bigint pw){
		Bigint ans=1;
		while(pw!=0){
			if(pw%2 !=0) ans*=base;
			base*=base, pw/=2;
		}
		return ans;
	}
	friend Bigint pow(Bigint a, Bigint b,Bigint mod) {
		if (b==0) return Bigint(1);
		Bigint tmp=pow(a,b/2,mod);
		if ((b%2)==0) return (tmp*tmp)%mod;
		else return (((tmp*tmp)%mod)*a)%mod;
	}
	friend Bigint sqrt(Bigint x) {
		Bigint ans=x,tmp=(x+1)/2;
		while (tmp<ans) ans=tmp, tmp=(tmp+x/tmp)/2;
		return ans;
	}
	friend Bigint gcd(Bigint a,Bigint b){
		return a%b==0 ? b : gcd(b, a%b);
	}
	friend Bigint lcm(Bigint a,Bigint b){
		return a/gcd(a,b);
	}
};
endsnippet



